name: Release and sync branches on dated commit

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: release-and-sync-main
  cancel-in-progress: false

jobs:
  release-and-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Check commit message for date
        id: parse
        shell: bash
        run: |
          msg='${{ github.event.head_commit.message }}'
          echo "Commit message: $msg"
          if [[ "$msg" =~ ([0-9]{2}\.[0-9]{2}\.[0-9]{4}) ]]; then
            date="${BASH_REMATCH[1]}"
            echo "Found date: $date"
            echo "date=$date" >> "$GITHUB_OUTPUT"
          else
            echo "No date pattern (dd.MM.yyyy) found in commit message. Skipping."
            echo "skip=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Stop if no date present
        if: steps.parse.outputs.skip == 'true'
        run: echo "No dated commit. Job ends."

      - name: Create release and open/merge PRs
        if: steps.parse.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const date = `${{ steps.parse.outputs.date }}`;
            const sha = context.sha;

            core.info(`Preparing release for date: ${date} at sha ${sha}`);

            // Try to get release by tag, otherwise create it (will also create the tag)
            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({ owner, repo, tag: date });
              core.info(`Release already exists: ${release.data.html_url}`);
            } catch (e) {
              core.info('Release not found, creating...');
              release = await github.rest.repos.createRelease({
                owner,
                repo,
                tag_name: date,
                target_commitish: 'main',
                name: `Release ${date}`,
                body: `Automated release for ${date}.\nCommit: ${sha}`,
                draft: false,
                prerelease: false
              });
              core.info(`Release created: ${release.data.html_url}`);
            }

            // List branches and filter out main
            const branchesResp = await github.rest.repos.listBranches({ owner, repo, per_page: 100 });
            const branches = branchesResp.data.map(b => b.name).filter(n => n !== 'main');
            core.info(`Target branches: ${branches.join(', ') || '(none)'}`);

            for (const baseBranch of branches) {
              // Check if there is already an open PR from main to this branch
              const prs = await github.rest.pulls.list({ owner, repo, state: 'open', base: baseBranch, per_page: 100 });
              let existing = prs.data.find(pr => pr.head && pr.head.ref === 'main');
              if (!existing) {
                core.info(`Creating PR from main to ${baseBranch}...`);
                const pr = await github.rest.pulls.create({
                  owner,
                  repo,
                  title: `Sync main -> ${baseBranch} (${date})`,
                  head: 'main',
                  base: baseBranch,
                  body: `Automated sync from main on ${date}.\nCommit: ${sha}`
                });
                existing = pr.data;
                core.info(`PR #${existing.number} created for ${baseBranch}`);
              } else {
                core.info(`Existing PR #${existing.number} found for ${baseBranch}`);
              }

              // Try to merge the PR immediately (will fail if there are conflicts or protections)
              try {
                const merge = await github.rest.pulls.merge({ owner, repo, pull_number: existing.number, merge_method: 'merge' });
                core.info(`PR #${existing.number} merged into ${baseBranch}: ${merge.data.merged}`);
              } catch (err) {
                core.warning(`Auto-merge failed for ${baseBranch}: ${err.message}. PR left open for manual review.`);
              }
            }

          result-encoding: string
